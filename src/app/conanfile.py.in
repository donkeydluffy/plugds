# 通用 conanfile.py 的模板内容
# 生成到 project_root/src/liba/conanfile.py.in
from conan import ConanFile
from conans import tools
from conan.errors import ConanInvalidConfiguration
from conan.tools.build import check_min_cppstd
from conan.tools.cmake import CMake, CMakeToolchain, CMakeDeps, cmake_layout
from conan.tools.files import (
    get,
    copy,
    rmdir,
    replace_in_file,
    apply_conandata_patches,
    export_conandata_patches,
)
from conan.tools.microsoft import check_min_vs, is_msvc, is_msvc_static_runtime
from conan.tools.scm import Version
import os

required_conan_version = ">=1.53.0"


class appPackageConan(ConanFile):
    settings = "os", "compiler", "build_type", "arch"
    license = "Scantech"
    no_copy_source = True
    name = "app"
    default_options = {}

    def _convert_value(self, value_str):
        """尝试将字符串值转换为 Python 类型 (bool, int)。"""
        val_lower = value_str.lower()
        if val_lower == "true":
            return True
        if val_lower == "false":
            return False
        try:
            return int(value_str)
        except ValueError:
            # 如果都不是，则保持为字符串
            return value_str

    def _apply_options(self, option_strings):
        """
        解析选项字符串并将其应用到 self.default_options 对象上。

        :param option_strings: 一个字符串列表，例如 ["fmt:header_only=True", "openssl:no_threads=False"]。
        """
        for opt_string in option_strings:
            # 1. 按 '=' 分割键和值
            try:
                key, value_str = opt_string.split("=", 1)
            except ValueError:
                self.output.warn(
                    f"Could not parse option '{opt_string}', missing '='. Skipping."
                )
                continue

            # 转换值的类型
            value = self._convert_value(value_str)

            self.output.info(f"Applying default option: {key} = {value}")
            self.default_options[key] = value

    # 获取当前平台
    def _get_current_platform(self):
        """获取当前平台"""
        try:
            if os.getenv("CONAN_TARGET_OS_NAME"):
                os_setting = os.getenv("CONAN_TARGET_OS_NAME").lower()
                mapping = {
                    "windows": "windows",
                    "linux": "linux",
                    "darwin": "macos",
                    "android": "android",
                }
                return mapping.get(os_setting, os_setting)
        except Exception:
            pass

        # 备选方案：使用 platform 模块
        import platform
        system = platform.system().lower()
        platform_mapping = {
            'windows': 'windows',
            'linux': 'linux',
            'darwin': 'macos',
            'android': 'android',
        }
        
        # Check if we're cross-compiling for Android
        if hasattr(self, 'settings') and hasattr(self.settings, 'os') and str(self.settings.os) == 'Android':
            return 'android'
            
        return platform_mapping.get(system, system)


    def config_options(self):
        pass

    def init(self):
        current_platform = self._get_current_platform()

        # 定义所有可能的平台选项
        platform_options = {
            'windows': "@APP_CONAN_PKG_OPTIONS_WINDOWS@",
            'linux': "@APP_CONAN_PKG_OPTIONS_LINUX@",
            'macos': "@APP_CONAN_PKG_OPTIONS_MACOS@",
            'android': "@APP_CONAN_PKG_OPTIONS_ANDROID@",
        }

        # 始终包含的通用选项
        options_strings = [
            "@APP_CONAN_PKG_OPTIONS@",
        ]

        # 添加当前平台特定的选项
        if current_platform in platform_options:
            options_strings.append(platform_options[current_platform])

        # 处理所有选项字符串
        all_options = []

        for options_str in options_strings:
            # 跳过空字符串或未替换的模板变量
            if not options_str or options_str.startswith("@") and options_str.endswith("@"):
                continue

            # 以分号分割，得到列表
            options_list = [opt.strip() for opt in options_str.split(";") if opt.strip()]
            all_options.extend(options_list)

        # 去重
        all_options = list(dict.fromkeys(all_options))

        self.output.info(f"Current platform: {current_platform}")
        self.output.info(f"Processing options: {all_options}")

        # 赋值给 default_options
        self._apply_options(all_options)

    def layout(self):
        cmake_layout(self, src_folder=".")

    def requirements(self):
        current_platform = self._get_current_platform()

        # 定义所有可能的平台包
        platform_requires = {
            'windows': "@APP_CONAN_PKGS_WINDOWS@",
            'linux': "@APP_CONAN_PKGS_LINUX@",
            'macos': "@APP_CONAN_PKGS_MACOS@",
            'android': "@APP_CONAN_PKGS_ANDROID@",
        }

        # 始终包含的通用包
        requires_strings = [
            "@APP_CONAN_PKGS@",
        ]

        # 添加当前平台特定的包
        if current_platform in platform_requires:
            requires_strings.append(platform_requires[current_platform])

        # 处理所有包字符串
        all_requires = []
        for requires_str in requires_strings:
            # 跳过空字符串或未替换的模板变量
            if not requires_str or requires_str.startswith("@") and requires_str.endswith("@"):
                continue

            # 过滤空字符串并去除空格
            requires_list = [
                req.strip() for req in requires_str.split(";") if req.strip()
            ]
            all_requires.extend(requires_list)

        # 去重
        all_requires = list(dict.fromkeys(all_requires))

        for req in all_requires:
            self.output.info(f"Applying requires: {req}")
            self.requires(req)

    def build_requirements(self):
        pass

    def validate(self):
        if self.settings.compiler.get_safe("cppstd"):
            check_min_cppstd(self, 17)

    def source(self):
        """
        Copies sources from the local directory (where 'conan create .' is run)
        to the Conan source folder. This keeps private code off the server.
        """
        local_path = os.getenv("APP_CONAN_CREATE_SOURCE_PATH")
        if not local_path:
            # 如果没有设置，则可以选择抛出异常或者默认行为
            from conan.errors import ConanException

            raise ConanException(
                "The APP_CONAN_CREATE_SOURCE_PATH environment variable is not set."
            )
        # 验证路径是否存在
        if not os.path.isdir(local_path):
            from conan.errors import ConanException

            raise ConanException(
                f"The specified APP_CONAN_CREATE_SOURCE_PATH directory does not exist: {local_path}"
            )
        # 将本地源码复制到 source() 工作目录中（通常是 self.source_folder）
        self.output.info("Copying sources from local path: {}".format(local_path))
        copy(
            self,
            "*",
            src=local_path,
            dst=self.source_folder,
        )

    def generate(self):
        tc = CMakeToolchain(self)
        tc.cache_variables["CMAKE_POLICY_DEFAULT_CMP0091"] = "NEW"

        # 从环境变量获取版本信息并传递给 CMake
        product_version = "@APP_PRODUCT_VERSION@"
        product_version_revision = "@APP_PRODUCT_VERSION_REVISION@"
        find_pkg_names = "@APP_FIND_PACKAGE_NAMES@"
        find_pkg_names_windows = "@APP_FIND_PACKAGE_NAMES_WINDOWS@"
        find_pkg_names_linux = "@APP_FIND_PACKAGE_NAMES_LINUX@"
        find_pkg_names_macos = "@APP_FIND_PACKAGE_NAMES_MACOS@"
        find_pkg_names_android = "@APP_FIND_PACKAGE_NAMES_ANDROID@"
        find_subproject_pkg_names = "@APP_FIND_SUBPROJECT_PACKAGE_NAMES@"
        if find_subproject_pkg_names and find_subproject_pkg_names != "":
            # 如果有子项目的包名，则把子项目find加到整体的find中
            find_pkg_names = find_pkg_names + ";" + find_subproject_pkg_names
        targets_to_link = "@APP_TARGETS_TO_LINK@"
        targets_to_link_windows = "@APP_TARGETS_TO_LINK_WINDOWS@"
        targets_to_link_linux = "@APP_TARGETS_TO_LINK_LINUX@"
        targets_to_link_macos = "@APP_TARGETS_TO_LINK_MACOS@"
        targets_to_link_android = "@APP_TARGETS_TO_LINK_ANDROID@"

        if product_version:
            tc.variables["APP_PRODUCT_VERSION"] = product_version
            self.output.info(f"Setting APP_PRODUCT_VERSION to: {product_version}")

        if product_version_revision:
            tc.variables["APP_PRODUCT_VERSION_REVISION"] = product_version_revision
            self.output.info(
                f"Setting APP_PRODUCT_VERSION_REVISION to: {product_version_revision}"
            )

        if find_pkg_names:
            tc.variables[f"APP_FIND_PACKAGE_NAMES"] = find_pkg_names
            self.output.info(f"Setting APP_FIND_PACKAGE_NAMES to: {find_pkg_names}")
        if find_pkg_names_windows:
            tc.variables[f"APP_FIND_PACKAGE_NAMES_WINDOWS"] = find_pkg_names_windows
            self.output.info(f"Setting APP_FIND_PACKAGE_NAMES_WINDOWS to: {find_pkg_names_windows}")
        if find_pkg_names_linux:
            tc.variables[f"APP_FIND_PACKAGE_NAMES_LINUX"] = find_pkg_names_linux
            self.output.info(f"Setting APP_FIND_PACKAGE_NAMES_LINUX to: {find_pkg_names_linux}")
        if find_pkg_names_macos:
            tc.variables[f"APP_FIND_PACKAGE_NAMES_MACOS"] = find_pkg_names_macos
            self.output.info(f"Setting APP_FIND_PACKAGE_NAMES_MACOS to: {find_pkg_names_macos}")
        if find_pkg_names_android:
            tc.variables[f"APP_FIND_PACKAGE_NAMES_ANDROID"] = find_pkg_names_android
            self.output.info(f"Setting APP_FIND_PACKAGE_NAMES_ANDROID to: {find_pkg_names_android}")

        if targets_to_link:
            tc.variables[f"APP_TARGETS_TO_LINK"] = targets_to_link
            self.output.info(f"Setting APP_TARGETS_TO_LINK to: {targets_to_link}")
        if targets_to_link_windows:
            tc.variables[f"APP_TARGETS_TO_LINK_WINDOWS"] = targets_to_link_windows
            self.output.info(f"Setting APP_TARGETS_TO_LINK_WINDOWS to: {targets_to_link_windows}")
        if targets_to_link_linux:
            tc.variables[f"APP_TARGETS_TO_LINK_LINUX"] = targets_to_link_linux
            self.output.info(f"Setting APP_TARGETS_TO_LINK_LINUX to: {targets_to_link_linux}")
        if targets_to_link_macos:
            tc.variables[f"APP_TARGETS_TO_LINK_MACOS"] = targets_to_link_macos
            self.output.info(f"Setting APP_TARGETS_TO_LINK_MACOS to: {targets_to_link_macos}")
        if targets_to_link_android:
            tc.variables[f"APP_TARGETS_TO_LINK_ANDROID"] = targets_to_link_android
            self.output.info(f"Setting APP_TARGETS_TO_LINK_ANDROID to: {targets_to_link_android}")

        # tc.variables["CMAKE_SYSTEM_NAME"] = os.getenv("CONAN_TARGET_OS_NAME")

        tc.generate()
        cmake_deps = CMakeDeps(self)
        cmake_deps.generate()

    def build(self):
        cmake = CMake(self)
        cmake.configure()
        cmake.build()

    def package(self):
        cmake = CMake(self)
        cmake.install()

    def package_info(self):
        if not hasattr(self, "name") or not self.name:
            # 如果没有定义 name 属性，可以从文件夹结构猜测或硬编码一个，但这不推荐
            # 最好在类定义开始时明确设置 self.name
            effective_name = (
                os.path.basename(os.path.dirname(self.recipe_folder))
                if self.recipe_folder
                else "unknown_package"
            )
            self.output.warn(
                f"Package name not explicitly set. Using '{effective_name}' for package_info."
            )
        else:
            effective_name = self.name

        self.cpp_info.libs = tools.collect_libs(self)
        include_path = os.path.join(self.package_folder, "include")
        if not os.path.exists(include_path):
            self.cpp_info.includedirs = []
        self.cpp_info.set_property("cmake_file_name", f"{effective_name}")
        self.cpp_info.set_property(
            "cmake_target_name", f"{effective_name}::{effective_name}"
        )
        self.cpp_info.set_property("pkg_config_name", f"{effective_name}")
        if self.options.get_safe("shared") is not None:
            self.cpp_info.set_property("is_shared", self.options.shared)